function [] = outputCSGInfo(CSGs,refOTU_taxonomy,origOTUIdx,outputDir)
% output several files providing information on consensus signature groups
% (CSGs)
%
% CSGEnrichOrder.txt, CSGEnrichFamily.txt, CSGEnrichGenus.txt are
% tab-delimited files, with line j in each file
% containing taxonomic labels at the Order, family, or genus level that are
% significantly enriched among refOTUs belonging to CSG j
%
% CSGMembers.txt is a tab-delimited file, listing the refOTUs in
% each CSG including the subject # the refOTU belongs to, its absolute &
% relative reference #'s, and its taxonomic labeling
%
% CSGSummary.txt is a tab-delimited file, w/ line j containing the # of
% refOTUs in CSG j belonging to each subject
%
% inputs:
% CSGs = cell array, CSGs{i} is a cell array of refOTUObjects belonging to
% consensus signature group i, generated by consensusSignatureGroups
% refOTU_taxonomy = cell array of taxonomic labels for each refOTU
% origOTUIdx = indices for original refOTUs, calculated by filterData
% outputDir = directory to output files
%
% Microbial Counts Trajectories Infinite Mixture Model Engine (MC-TIMME)
% Copyright (C) 2012 Georg Gerber
% outputCSGInfo.m (version 1.00)

% false discovery rate threshold for determining significance of taxonomic label
% enrichment
FDR = 0.05;
% minimum refOTUs that must be in a CSG for a taxonomic label to be considered significantly enriched
minInCSG = 5;
% parse taxonomy into cell arrays
taxonomy = parseTaxonomy(refOTU_taxonomy);

numSubjects = length(origOTUIdx);

% initialize structures for counting taxonomic labels
familyMap = cell(numSubjects,1);
genusMap = cell(numSubjects,1);
orderMap = cell(numSubjects,1);
familyTotal = zeros(numSubjects,1);
genusTotal = zeros(numSubjects,1);
orderTotal = zeros(numSubjects,1);
numOTUs = zeros(numSubjects,1);
for ds=1:numSubjects,
    numOTUs(ds) = length(origOTUIdx{ds});
    [orderMap{ds},orderTotal(ds),familyMap{ds},familyTotal(ds),genusMap{ds},genusTotal(ds)] = calcTaxonomyMap(taxonomy,origOTUIdx{ds});
end;
pv_order = cell(length(CSGs),1);
pvo = [];
name_order = cell(length(CSGs),1);
num_order = cell(length(CSGs),1);
idx_order = cell(length(CSGs),1);
pv_family = cell(length(CSGs),1);
pvf = [];
name_family = cell(length(CSGs),1);
num_family = cell(length(CSGs),1);
idx_family = cell(length(CSGs),1);
pv_genus = cell(length(CSGs),1);
pvg = [];
name_genus = cell(length(CSGs),1);
num_genus = cell(length(CSGs),1);
idx_genus = cell(length(CSGs),1);
inCl = cell(length(CSGs),1);

for ncc=1:length(CSGs),
    % maps to track # of refOTUs w/ the same taxonomic label
    tOrderMap = java.util.HashMap;
    tFamilyMap = java.util.HashMap;
    tGenusMap = java.util.HashMap;
    dOrderMap = cell(1,numSubjects);
    dFamilyMap = cell(1,numSubjects);
    dGenusMap = cell(1,numSubjects);
    inCln = zeros(1,numSubjects);
    for ds=1:numSubjects,
        % track # of refOTUs from this subject in this CSG w/ the same taxonomic label
        dOrderMap{ds} = java.util.HashMap;
        dFamilyMap{ds} = java.util.HashMap;
        dGenusMap{ds} = java.util.HashMap;
        % count # of members in this CSG from this subject
        inCln(ds) = 0;
        % find all members of this CSG from this subject
        for onn=1:length(CSGs{ncc}),
            roo = CSGs{ncc}{onn};
            if roo.subjNum == ds,
                otu = roo.origOTU;
                % get class label
                cn = taxonomy{otu,4};
                % get family label
                fn = taxonomy{otu,5};
                % get genus label
                gn = taxonomy{otu,6};
                % add labels to maps
                tOrderMap = addToMap(tOrderMap,cn);
                dOrderMap{ds} = addToMap(dOrderMap{ds},cn);
                tFamilyMap = addToMap(tFamilyMap,fn);
                dFamilyMap{ds} = addToMap(dFamilyMap{ds},fn);
                tGenusMap = addToMap(tGenusMap,gn);
                dGenusMap{ds} = addToMap(dGenusMap{ds},gn);
                inCln(ds) = inCln(ds) + 1;
            end;
        end;
    end;
    inCl{ncc} = inCln;
    
    ona = tOrderMap.keySet.toArray;
    fna = tFamilyMap.keySet.toArray;
    gna = tGenusMap.keySet.toArray;
    
    % calculate p-values at Order level
    if length(ona)>0,
        nnv = zeros(1,length(ona));
        for i=1:length(ona),
           nnv(i) = tOrderMap.get(ona(i));
        end;
        fff = find(nnv >= minInCSG);
        
        if ~isempty(fff),
            names = cell(1,length(fff));
            pv = zeros(1,length(fff));
            pvidx = zeros(1,length(fff));
            nm = zeros(numSubjects,length(fff));
            for i=1:length(fff),
                names{i} = ona(fff(i));
                totalInCSG = tOrderMap.get(names{i});
                totalInDS = 0;
                for ds=1:numSubjects,
                    if orderMap{ds}.containsKey(names{i}) == 1,
                        totalInDS = totalInDS + orderMap{ds}.get(names{i});
                    end;
                    if dOrderMap{ds}.containsKey(names{i}) == 1,
                        nm(ds,i) = dOrderMap{ds}.get(names{i});
                    end;
                end;
                % calculate p-value w/ hypergeometric distribution as null
                % hypothesis
                pv(i) = 1-hygecdf(totalInCSG,sum(numOTUs),totalInDS,length(CSGs{ncc}));
                pvo = [pvo pv(i)];
                pvidx(i) = length(pvo);
            end;
            pv_order{ncc} = pv;
            name_order{ncc} = names;
            num_order{ncc} = nm;
            idx_order{ncc} = pvidx;
        end;
    end;
    
     % calculate p-values at Family level
    if length(fna)>0,
        nnv = zeros(1,length(fna));
        for i=1:length(fna),
           nnv(i) = tFamilyMap.get(fna(i));
        end;
        fff = find(nnv >= minInCSG);
        
        if ~isempty(fff),
            names = cell(1,length(fff));
            pv = zeros(1,length(fff));
            pvidx = zeros(1,length(fff));
            nm = zeros(numSubjects,length(fff));
            for i=1:length(fff),
                names{i} = fna(fff(i));
                totalInCSG = tFamilyMap.get(names{i});
                totalInDS = 0;
                for ds=1:numSubjects,
                    if familyMap{ds}.containsKey(names{i}) == 1,
                        totalInDS = totalInDS + familyMap{ds}.get(names{i});
                    end;
                    if dFamilyMap{ds}.containsKey(names{i}) == 1,
                        nm(ds,i) = dFamilyMap{ds}.get(names{i});
                    end;
                end;
                pv(i) = 1-hygecdf(totalInCSG,sum(numOTUs),totalInDS,length(CSGs{ncc}));
                pvf = [pvf pv(i)];
                pvidx(i) = length(pvf);
            end;
            pv_family{ncc} = pv;
            name_family{ncc} = names;
            num_family{ncc} = nm;
            idx_family{ncc} = pvidx;
        end;
    end;
   
    % calculate p-values at Genus level
    if length(gna) >0,
        nnv = zeros(1,length(gna));
        for i=1:length(gna),
           nnv(i) = tGenusMap.get(gna(i));
        end;
        fff = find(nnv >= minInCSG);
        
        if ~isempty(fff),
            names = cell(1,length(fff));
            pv = zeros(1,length(fff));
            pvidx = zeros(1,length(fff));
            nm = zeros(numSubjects,length(fff));
            for i=1:length(fff),
                names{i} = gna(fff(i));
                totalInCSG = tGenusMap.get(names{i});
                totalInDS = 0;
                for ds=1:numSubjects,
                    if genusMap{ds}.containsKey(names{i}) == 1,
                        totalInDS = totalInDS + genusMap{ds}.get(names{i});
                    end;
                    if dGenusMap{ds}.containsKey(names{i}) == 1,
                        nm(ds,i) = dGenusMap{ds}.get(names{i});
                    end;
                end;
                pv(i) = 1-hygecdf(totalInCSG,sum(numOTUs),totalInDS,length(CSGs{ncc}));
                pvg = [pvg pv(i)];
                pvidx(i) = length(pvg);
            end;
            pv_genus{ncc} = pv;
            name_genus{ncc} = names;
            num_genus{ncc} = nm;
            idx_genus{ncc} = pvidx;
        end;
    end;
end;

% calculate false discovery rate values using linear step-up (LSU) procedure originally introduced by Benjamini and Hochberg, 1995
pvo_FDR = mafdr(pvo,'BHFDR',true);
pvf_FDR = mafdr(pvf,'BHFDR',true);
pvg_FDR = mafdr(pvg,'BHFDR',true);

% output taxonomic label enrichments
CSGEnrichOrderFileN = [outputDir '_CSGEnrichOrder.txt'];
CSGEnrichOrderFile = fopen(CSGEnrichOrderFileN,'w');
CSGEnrichFamilyFileN = [outputDir '_CSGEnrichFamily.txt'];
CSGEnrichFamilyFile = fopen(CSGEnrichFamilyFileN,'w');
CSGEnrichGenusFileN = [outputDir '_CSGEnrichGenus.txt'];
CSGEnrichGenusFile = fopen(CSGEnrichGenusFileN,'w');

% output at Order level
for ncc=1:length(CSGs),
    fprintf(CSGEnrichOrderFile,'CSG#%i',ncc);
    if ~isempty(num_order{ncc}),   
        for i=1:length(idx_order{ncc}),
            if pvo_FDR(idx_order{ncc}(i)) <= FDR,
                fprintf(CSGEnrichOrderFile,'\t%s FDR=%f n=',char(name_order{ncc}(i)),pvo_FDR(idx_order{ncc}(i)));
                for ds=1:numSubjects,
                    if ds > 1,
                        fprintf(CSGEnrichOrderFile,'+');
                    end;
                    fprintf(CSGEnrichOrderFile,'%i',num_order{ncc}(ds,i));
                end;
            end;
        end;
    end;
    fprintf(CSGEnrichOrderFile,'\n');
end;

% output at Family level
for ncc=1:length(CSGs),
    fprintf(CSGEnrichFamilyFile,'CSG#%i',ncc);
    if ~isempty(num_family{ncc}),
        for i=1:length(idx_family{ncc}),
            if pvf_FDR(idx_family{ncc}(i)) <= FDR,
                fprintf(CSGEnrichFamilyFile,'\t%s FDR=%f n=',char(name_family{ncc}(i)),pvf_FDR(idx_family{ncc}(i)));
                for ds=1:numSubjects,
                    if ds > 1,
                        fprintf(CSGEnrichFamilyFile,'+');
                    end;
                    fprintf(CSGEnrichFamilyFile,'%i',num_family{ncc}(ds,i));
                end;
            end;
        end;
    end;
    fprintf(CSGEnrichFamilyFile,'\n');
end;

% output at Genus level
for ncc=1:length(CSGs),
    fprintf(CSGEnrichGenusFile,'CSG#%i',ncc);
    if ~isempty(num_genus{ncc}),
        for i=1:length(idx_genus{ncc}),
            if pvg_FDR(idx_genus{ncc}(i)) <= FDR,
                fprintf(CSGEnrichGenusFile,'\t%s FDR=%f n=',char(name_genus{ncc}(i)),pvg_FDR(idx_genus{ncc}(i)));
                for ds=1:numSubjects,
                    if ds > 1,
                        fprintf(CSGEnrichGenusFile,'+');
                    end;
                    fprintf(CSGEnrichGenusFile,'%i',num_genus{ncc}(ds,i));
                end;
            end;
        end;
    end;
    fprintf(CSGEnrichGenusFile,'\n');
end;
fclose('all');

% output CSG refOTU members
CSGMembersFileN = [outputDir '_CSGMembers.txt'];
CSGMembersFile = fopen(CSGMembersFileN,'w');

fprintf(CSGMembersFile,'CSG#\tSubject#\trel refOTU#\tabs refOTU#\ttaxonomy\n');
for ncc=1:length(CSGs),
    fprintf(CSGMembersFile,'%i\n',ncc);
    for i=1:length(CSGs{ncc}),
        roo = CSGs{ncc}{i};
        fprintf(CSGMembersFile,'\t%i\t%i\t%i\t%s\n',roo.subjNum,roo.OTUNum,roo.origOTU,refOTU_taxonomy{roo.origOTU});
    end;
    fprintf(CSGMembersFile,'\n');
end;

CSGSummaryFileN = [outputDir '_CSGSummary.txt'];
CSGSummaryFile = fopen(CSGSummaryFileN,'w');
fprintf(CSGSummaryFile,'CSG #');
for ds=1:numSubjects,
    fprintf(CSGSummaryFile,'\t# refOTUs subj %i',ds);
end;
fprintf(CSGSummaryFile,'\n');
for i=1:length(inCl),
    fprintf(CSGSummaryFile,'%i',i);
    fprintf(CSGSummaryFile,'\t%i',inCl{i});
    fprintf(CSGSummaryFile,'\n');
end;

fclose('all');

function [OrderMap,OrderTotal,familyMap,familyTotal,genusMap,genusTotal] = calcTaxonomyMap(taxonomy,useOTUs)
% utility function to create Java HashMaps for counting taxonomic entries
OrderMap = java.util.HashMap;
familyMap = java.util.HashMap;
genusMap = java.util.HashMap;

OrderTotal = 0;
familyTotal = 0;
genusTotal = 0;

for idx=1:length(useOTUs),
    otu = useOTUs(idx);
    cn = taxonomy{otu,4};
    fn = taxonomy{otu,5};
    gn = taxonomy{otu,6};
    
    if ~isempty(cn),
        if OrderMap.containsKey(cn) == 0,
            OrderMap.put(cn,0);
        end;
        cc = OrderMap.get(cn);
        cc = cc + 1;
        OrderMap.put(cn,cc);
        OrderTotal = OrderTotal + 1;
    end;
    
    if ~isempty(fn),
        if familyMap.containsKey(fn) == 0,
            familyMap.put(fn,0);
        end;
        fc = familyMap.get(fn);
        fc = fc + 1;
        familyMap.put(fn,fc);
        familyTotal = familyTotal + 1;
    end;
    
   if ~isempty(gn),
        if genusMap.containsKey(gn) == 0,
            genusMap.put(gn,0);
        end;
        gc = genusMap.get(gn);
        gc = gc + 1;
        genusMap.put(gn,gc);
        genusTotal = genusTotal + 1;
    end;
end;

function [myMap2] = addToMap(myMap,myName)
% utility function for adding to a HashMap
    myMap2 = myMap;
    if ~isempty(myName),
        if myMap2.containsKey(myName) == 0,
            myMap2.put(myName,0);
        end;
        c = myMap2.get(myName);
        c = c + 1;
        myMap2.put(myName,c);
    end;

function [taxonomy2] = parseTaxonomy(taxonomy)
% utility function to parse ';' delimited taxonomy into cell structure
taxonomy2 = cell(length(taxonomy),6);
for i=1:length(taxonomy),
    [s] = getLevels(taxonomy{i});
    for j=1:length(s),
        taxonomy2(i,j) = s(j);
    end;
end;

function [s2] = getLevels(tax)
% helper function for parse taxonomy
s =  regexp(tax, '[;_]', 'split');
s2 = cell(1,length(s));

filterC = [];
for i=1:length(s),
    s2{i} = s{i};
    [x, status] = str2num(s{i});
    unc = strmatch('uncultured',s{i});
    unc2 = strmatch('Incertae Sedis',s{i});
    if status==1 | length(unc)>0 | length(unc2)>0,,
        filterC = [filterC i];
    end;
end;
s2(filterC) = [];