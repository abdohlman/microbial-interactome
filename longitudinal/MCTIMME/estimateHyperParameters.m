function [hparams] = estimateHyperParameters(D_filtered,psi,times,timeIntervals,dataIdx)
% estimate MC-TIMME hyperparameters from data
%
% inputs:
% D_filtered =  data w/ refOTUs removed that don't pass filtering criteria
% (generated by filterData.m)
% psi = subject and time-point specific offsets based on total reads (generated by filterData.m)
% times = cell array of time-points for each subject
% timeIntervals = cell array specifying time-intervals for each subject
% dataIdx = indices used for subsequent mapping back to original data (generated by filterData.m)
%
% output:
% hparams = hyperParameters object
%
% Microbial Counts Trajectories Infinite Mixture Model Engine (MC-TIMME)
% Copyright (C) 2012 Georg Gerber
% estimateHyperParameters.m (version 1.00)

% create instance of hyperParameters object
hparams = hyperParameters;

% define a small offset, so that when log transforming for estimates
% will not get log 0
offset = 0.25;

% total # of subjects
numSubjects = length(D_filtered);

% create cell array for gamma hyperparameters
hparams.gamma = cell(numSubjects,1);

% temp variables for estimating hyperparameters
D2 = D_filtered;
D1 = cell(numSubjects,1);
dMap = cell(numSubjects,1);

for pt=1:numSubjects,
    % log transform refOTU counts
    D2{pt} = D2{pt} + offset;
    D2{pt} = log(D2{pt});
    % standardize counts using psi
    D1{pt} = D2{pt} - repmat(psi{pt},size(D_filtered{pt},1),1);
    % estimate gamma parameter for each refOTU
    hparams.gamma{pt} = mean(D1{pt},2);
    % now standardize refOTUs using gamma parameter
    D2{pt} = (D1{pt} - repmat(hparams.gamma{pt},1,size(D_filtered{pt},2)));
    dMap{pt} = dataIdx(pt,1):dataIdx(pt,2);
end;

% separate intervals into treatment, no treatment and initial
% (pre-treatment) intervals
[treatIntervals,noTreatIntervals,treatTimeIdx,noTreatTimeIdx] = separateIntervals(timeIntervals);

% variables to estimate NBD epsilon parameters from treatment and initial non-treatment interval
ep_initial = zeros(dataIdx(numSubjects,2),1);
ep_treat = [];
for pt=1:numSubjects,
    % estimate NBD parameters on initial intervals
    for i=1:(dataIdx(pt,2)-dataIdx(pt,1)+1),
        [mm1,vv1,ep_initial(dMap{pt}(i))] = nbinDataFit(round(exp(D1{pt}(i,timeIntervals{pt}{1}.startTimeIdx:timeIntervals{pt}{1}.endTimeIdx))));
    end;
end;
% now estimate NBD parameters on treatment intervals
for intv=1:length(treatIntervals{1}),
    ept = zeros(dataIdx(numSubjects,2),1);
    for pt=1:numSubjects,
        for i=1:(dataIdx(pt,2)-dataIdx(pt,1)+1),
            [mm1,vv1,ept(dMap{pt}(i))] = nbinDataFit(round(exp(D1{pt}(i,treatIntervals{pt}{intv}.startTimeIdx:treatIntervals{pt}{intv}.endTimeIdx))));
        end;
    end;
    ep_treat = [ep_treat ; ept];
end;
% estimate NDB epsilon_1 hyperparameters using initial interval data
hparams.m_epsilon_1 = nanmean(log(ep_initial));
hparams.sigma_epsilon_1 = nanstd(log(ep_initial));
% estimate NDB epsilon_2 hyperparameters using treatment interval data
hparams.m_epsilon_2 = nanmean(log(ep_treat));
hparams.sigma_epsilon_2 = nanstd(log(ep_treat));

% array to hold estimates of means for non-treatment intervals
m_mu = cell(length(noTreatIntervals{1}),1);
% array to hold estimates for relaxation time parameters
m_lambda = cell(length(noTreatIntervals{1})-1,1);

% guess (in days) for initializing lambda estimates
lambdaGuess = 7;

MT = zeros(dataIdx(numSubjects,2),1);
for pt=1:length(D_filtered),
    for i=1:(dataIdx(pt,2)-dataIdx(pt,1)+1),
        % for initial interval, just take mean b/c assumed steady-state
        MT(dMap{pt}(i)) = mean(D2{pt}(i,noTreatIntervals{pt}{1}.startTimeIdx:noTreatIntervals{pt}{1}.endTimeIdx));
    end;
end;
m_mu{1} = MT;

opts = optimset('Display','off');
for intv=2:length(noTreatIntervals{1}),
    MT = zeros(dataIdx(numSubjects,2),1);
    LT = zeros(dataIdx(numSubjects,2),1);
    for pt=1:length(D_filtered),
        for i=1:(dataIdx(pt,2)-dataIdx(pt,1)+1),  
            % to estimate mu & lambda by LSQ fit of data to 'exponential decay curve'
            p = lsqcurvefit(@expDecayCurve,[1/lambdaGuess D2{pt}(i,noTreatIntervals{pt}{intv}.startTimeIdx) m_mu{1}(dMap{pt}(i))],times{pt}(noTreatIntervals{pt}{intv}.startTimeIdx:noTreatIntervals{pt}{intv}.endTimeIdx)-times{pt}(noTreatIntervals{pt}{intv}.startTimeIdx),D2{pt}(i,noTreatIntervals{pt}{intv}.startTimeIdx:noTreatIntervals{pt}{intv}.endTimeIdx),[1/(2*hparams.lambdaMax) -Inf -Inf],[2*hparams.lambdaMin Inf Inf],opts);
            p(1)=1/p(1);
            if p(1) < hparams.lambdaMin,
                p(1)=hparams.lambdaMin;
            end;
            if p(1) > hparams.lambdaMax,
                p(1)=hparams.lambdaMax;
            end;
            % transform lambda
            K = (p(1)-hparams.lambdaMin)/(hparams.lambdaMax-hparams.lambdaMin);
            K = log(K./((1-K)));
            if isinf(K),
                K = NaN;
            end;
           LT(dMap{pt}(i)) = K;
           MT(dMap{pt}(i)) = p(3);
        end;  
    end;
    m_mu{intv} = MT;
    m_lambda{intv-1} = LT;
end;

% estimate lambda prior mean and std
hparams.m_beta_lambda_1 = nanmean(m_lambda{1});
hparams.sigma_beta_lambda_1 = nanstd(m_lambda{1});
hparams.v_rho_lambda_1 = hparams.sigma_beta_lambda_1^2;

% estimate prior variance for rho_lambda_2
delta_lambda = [];
if length(m_lambda)>1,
    for intv=2:length(m_lambda),
        delta_lambda = [delta_lambda ; m_lambda{intv}-m_lambda{intv-1}];
    end;
    nv = sum(~isnan(delta_lambda));
    v = nansum(delta_lambda.*delta_lambda);
    hparams.v_rho_lambda_2 = v/nv;
else,
    hparams.v_rho_lambda_2 = 0;
end;


% estimate prior mean & std for beta_0
hparams.m_beta_0 = mean(m_mu{1});
hparams.v_rho_0 = std(m_mu{1})^2;
hparams.sigma_beta_0 = 10*std(m_mu{1});

% estimate hyperparameters for 'drift' from adjacent means, rho_mu_1
% (non-treatment to non-treatment intervals)
delta_mu = [];
for intv=2:length(m_mu),
    delta_mu = [delta_mu ; m_mu{intv}-m_mu{intv-1}];
end;
sv = delta_mu .* delta_mu;
hparams.v_rho_mu_1 = sum(sv)/length(sv);

% estimate hyperparameters for 'drift' from adjacent means, rho_mu_2
% (non-treatment to treatment intervals)
m_treat_delta = [];
for intv=1:length(treatIntervals{1}),
    mt = zeros(dataIdx(numSubjects,2),1);
    for pt=1:length(D_filtered),
        for i=1:(dataIdx(pt,2)-dataIdx(pt,1)+1), 
            mt(dMap{pt}(i)) = mean(D2{pt}(i,treatIntervals{pt}{intv}.startTimeIdx:treatIntervals{pt}{intv}.endTimeIdx));
        end;
    end;
    m_treat_delta = [m_treat_delta ; mt-m_mu{intv}];
end;
sv = m_treat_delta .* m_treat_delta;
hparams.v_rho_mu_2 = sum(sv)/length(sv);

function [mu,v,epsilon] = nbinDataFit(Y)
% helper function to fit parameters to negative binomial
m1 = mean(Y);
m2 = std(Y)^2;
if m1 >= m2,
    p = poissfit(Y);
    mu = p;
    v = p;
    epsilon = NaN;
else,
    warning off;
    p = nbinfit(Y);
    [mu,v] = nbinstat(p(1),p(2));
    epsilon = (v-mu)/mu^2;
    if epsilon == 0,
        epsilon = NaN;
    end;
end;