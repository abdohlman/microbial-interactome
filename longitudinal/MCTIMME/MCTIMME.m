function [] = MCTIMME(baseDir,D,psi,hparams,times,timeIntervals,nodeID)
% main function to perform model inference using MCMC methods
%
% inputs:
% baseDir = a base directory to output files w/ MCMC samples
% D = cell array of refOTU count data for subjects (usually generated by
% filterData.m)
% psi = subject & time-point specific offsets, calculated by filterData.m
% hparams = hyperParameters object, calculated by estimateHyperParameters.m
% times = cell array of time-points for each subject
% timeIntervals = cell array specifying time-intervals for each subject
% nodeID = optional parameter to identify node for tracking progress in compute cluster environment
%
% Microbial Counts Trajectories Infinite Mixture Model Engine (MC-TIMME)
% Copyright (C) 2013 Georg Gerber
% MCTIMME.m (version 1.1) 10/01/2013

% if nodeID parameter not specified, set it to -1
if nargin == 6,
    nodeID = -1;
end;

% total # of MCMC iterations
num_MCMC_iters = 15000;
% # of burnin iterations
num_MCMC_burnin = 10000;
% number of iterations for estimating alpha
numAlphaIters = 15;
% acceptance counters for MH moves
num_accept_X = 0;
total_try_X = 0;
num_accept_epsilon1 = 0;
num_accept_epsilon2 = 0;

numSubjects = length(D);
numOTUs = zeros(numSubjects,1);
numTimepoints = zeros(numSubjects,1);
for ds=1:numSubjects,
    numOTUs(ds) = size(D{ds},1);
    numTimepoints(ds) = size(D{ds},2);
end;
foundCM = cell(numSubjects,1);

% set up arrays for rapidly calculating gamma & psi offsets
gammaM = cell(numSubjects,1);
psiM = cell(numSubjects,1);
for ds=1:numSubjects,
    gammaM{ds} = repmat(hparams.gamma{ds},1,numTimepoints(ds));
    psiM{ds} = repmat(psi{ds},numOTUs(ds),1);
end;

% separate time intervals into non-treatment and treatment (antibiotic)
% intervals
[treatIntervals,noTreatIntervals,treatTimeIdx,noTreatTimeIdx] = separateIntervals(timeIntervals);
numMuParams = length(noTreatIntervals{1});
numDeltaLambdaParams = numMuParams-2;
% # of possible different settings for c_mu
num_c_mu_states = 2^(numMuParams-1);
c_mu_idx = [];
for intv=2:length(timeIntervals{1}),
    if timeIntervals{1}{intv}.treat == 0,
        c_mu_idx = [c_mu_idx intv];
    end;
end;
c_mu_Configs = enumStates(num_c_mu_states);
convert_c_mu = zeros(1,log2(num_c_mu_states));
for i=1:length(convert_c_mu),
    convert_c_mu(i) = 2^(i-1);
end;
% # of possible different settings for c_lambda
num_c_lambda_states = 2^numDeltaLambdaParams;
c_lambda_Configs = [];
if numDeltaLambdaParams > 0,
    c_lambda_Configs = enumStates(num_c_lambda_states);
    convert_c_lambda = zeros(1,log2(num_c_lambda_states));
    for i=1:length(convert_c_lambda),
        convert_c_lambda(i) = 2^(i-1);
    end;
end;

% initialize model parameters
alpha = hparams.omega_alpha1/hparams.omega_alpha2;
beta_0 = hparams.m_beta_0;
rho_0 = sqrt(hparams.v_rho_0);
rho_mu_1 = sqrt(hparams.v_rho_mu_1);
rho_mu_2 = sqrt(hparams.v_rho_mu_2);
beta_lambda_1 = hparams.m_beta_lambda_1;
rho_lambda_1 = hparams.sigma_beta_lambda_1;
rho_lambda_2 = sqrt(hparams.v_rho_lambda_2);
mu_epsilon_1 = hparams.m_epsilon_1;
mu_epsilon_2 = hparams.m_epsilon_2;
rho_epsilon_1 = hparams.sigma_epsilon_1;
rho_epsilon_2 = hparams.sigma_epsilon_2;
epsilon_1 = mu_epsilon_1;
epsilon_2 = mu_epsilon_2;
pi_c_mu = ones(1,num_c_mu_states).*hparams.omega_pi_c_mu;
pi_c_mu = pi_c_mu/sum(pi_c_mu);
pi_c_lambda = [];
if num_c_lambda_states>1,
    pi_c_lambda = ones(1,num_c_lambda_states).*hparams.omega_pi_c_lambda;
    pi_c_lambda = pi_c_lambda/sum(pi_c_lambda);
end;

% tuning parameters for sampling epsilons
tune_epsilon_1 = 0.01;
tune_epsilon_2 = 0.01;
v_epsilon_1_sample = hparams.sigma_epsilon_1*tune_epsilon_1;
v_epsilon_2_sample = hparams.sigma_epsilon_2*tune_epsilon_2;
% tuning parameters for sampling lambda_1 & lambda_2
tune_lambda_1 = 0.5;
s_tune_lambda_1 = tune_lambda_1*rho_lambda_1/10.0;
tune_lambda_2 = 0.5;
s_tune_lambda_2 = tune_lambda_2*rho_lambda_2/10.0;

% set up variables for prototype signatures
% for efficiency, preallocate signatures
signatureBuffer = 500;
% size to grow signature buffer by
growSignatureBuffer = 10;
activeSignatures = 1;
inactiveSignatures = (2:signatureBuffer)';
% # of signatures w/ non-zero members
numSignatures = 1;
% signature membership variables
numSignatureMembers = zeros(signatureBuffer,1);
% initially allocate all data to one signature
numSignatureMembers(1) = sum(numOTUs);

% assignments for refOTU time-series to signatures
signatureAssigns = cell(numSubjects,1);
% data log likelihood for refOTU time-series
LL_data = cell(numSubjects,1);
temp_LL = cell(numSubjects,1);
% GLM parameterization for refOTU time-series
enu = cell(numSubjects,1);
nu = cell(numSubjects,1);
enu_new = cell(numSubjects,1);
nu_new = cell(numSubjects,1);
temp_enu = cell(numSubjects,1);
temp_nu = cell(numSubjects,1);
for ds=1:numSubjects,
    temp_enu{ds} = zeros(signatureBuffer,numTimepoints(ds));
    temp_nu{ds} = zeros(signatureBuffer,numTimepoints(ds));
end;
L = zeros(1,signatureBuffer);

% relaxation time parameters for each signature
lambda_1 = ones(signatureBuffer,1)*beta_lambda_1;
if numDeltaLambdaParams>0,
    lambda_2 = zeros(signatureBuffer,numDeltaLambdaParams);
else,
    lambda_2 = [];
end;
% adapative complexity parameters for each signature
c_mu = num_c_mu_states*ones(signatureBuffer,1);
c_lambda = [];
if numDeltaLambdaParams>0,
    c_lambda = num_c_lambda_states*ones(signatureBuffer,1);
end;
% equilibrium level parameters for each signature
numSignatureParams = length(timeIntervals{1});
X = zeros(signatureBuffer,numSignatureParams);
% coefficient (design) matrices for each signature
B = cell(signatureBuffer,1);
% B * X for each signature
BX = cell(numSubjects,1);
% initialize variables
for ds=1:numSubjects,
    signatureAssigns{ds} = ones(numOTUs(ds),1);
    LL_data{ds} = zeros(numOTUs(ds),1);
    enu{ds} = zeros(numOTUs(ds),numTimepoints(ds));
    nu{ds} = zeros(numOTUs(ds),numTimepoints(ds));
    enu_new{ds} = zeros(numOTUs(ds),numTimepoints(ds));
    nu_new{ds} = zeros(numOTUs(ds),numTimepoints(ds));
    temp_LL{ds} = zeros(numOTUs(ds),1);
    BX{ds} = zeros(signatureBuffer,numTimepoints(ds));
end;
reverseSignatureMap = zeros(1,signatureBuffer);

% prior (inverse) covariance matrix for each c_mu configuration
% used in WLS estimate of GLM
R_inv = cell(num_c_mu_states,1);
c_mu_MapDim = cell(num_c_mu_states,1);
c_mu_DelDim = cell(num_c_mu_states,1);
for j=1:num_c_mu_states,
    vp = zeros(1,numSignatureParams);
    vp(1) = rho_0^2;
    for intv=2:length(timeIntervals{1}),
        if timeIntervals{1}{intv}.treat == 0,
            vp(intv) = rho_mu_1^2;
        else,
            vp(intv) = rho_mu_2^2;
        end;
    end;
    c_mu_MapDim{j} = 1:numSignatureParams;
    % remove dimensions that aren't present in configuration
    f = find(c_mu_Configs(j,:) == 0);
    c_mu_MapDim{j}(c_mu_idx(f)) = [];
    if ~isempty(f),
        vp(c_mu_idx(f)) = []; 
        c_mu_DelDim{j} = c_mu_idx(f);
    else,
        c_mu_DelDim{j} = [];
    end;
    R_inv{j} = diag(1./vp);
end;
% define a small offset, so that when log transforming for signature
% initialization estimates will not get log 0
offset = 0.25;
% initialize signature(s)
for ncc=1:numSignatures,
    k = activeSignatures(ncc);
    Bt = cell(numSubjects,1);
    for ds=1:numSubjects,
        % find refOTUs assigned to signature k
        foundCM{ds} = find(signatureAssigns{ds} == k);
        % generate design matrix
        delta_lambda = [];
        if ~isempty(lambda_2),
            delta_lambda = lambda_2(k,:);
        end;
        Bt{ds} = designMatrix(times{ds},timeIntervals{ds},lambda_1(k),delta_lambda,hparams.lambdaMin,hparams.lambdaMax);
        % estimate GLM parameters
        enu{ds}(foundCM{ds},:) = D{ds}(foundCM{ds},:) + offset;
        nu{ds}(foundCM{ds},:) = log(enu{ds}(foundCM{ds},:));
    end;
    % calculate posterior mean and cov matrix for WLS estimate
    B{k} = Bt;
    [B_D,B_W] = transformData(foundCM,size(B{k}{1},2),Bt,D,psiM,gammaM,nu,enu,exp(epsilon_1),exp(epsilon_2),noTreatTimeIdx,treatTimeIdx);
    C_new = (R_inv{c_mu(k)}+B_W);
    C_new = inv(C_new);
    po =  [R_inv{c_mu(k)}(1,1)*beta_0 ; zeros(length(timeIntervals{1})-1,1)];
    m_new = C_new * (B_D + po);
    % sample equilibrium level parameters from WLS estimate of
    % posterior
    X(k,:) = mvnrnd(m_new,C_new)';
   
    for ds=1:numSubjects,
        BX{ds}(k,:) = B{k}{ds}*X(k,:)';
    end;
    
    for ds=1:numSubjects,
        if ~isempty(foundCM{ds}),
            % update GLM parameters and data log likelihoods
            nu{ds}(foundCM{ds},:) = repmat(BX{ds}(k,:),length(foundCM{ds}),1) + psiM{ds}(foundCM{ds},:) + gammaM{ds}(foundCM{ds},:);
            enu{ds}(foundCM{ds},:) = exp(nu{ds}(foundCM{ds},:));
            LL_data{ds}(foundCM{ds}) = calcDataLL(D{ds}(foundCM{ds},:),enu{ds}(foundCM{ds},:),noTreatTimeIdx{ds},treatTimeIdx{ds},exp(epsilon_1),exp(epsilon_2));
        end;
    end;
end;

% initialize output files, which will store MCMC samples
[fid_hyperParams,fid_signatureParameters,fid_signatureAssigns] = initOutputFiles(baseDir,numSubjects);

% generate MCMC samples
for iter=1:num_MCMC_iters,
    % set denominator for conditional likelihood calculations
    r2 = sum(numOTUs) - 1 + alpha;
    % go through each refOTU time-series in each subject and assign to signatures
    for ds=1:numSubjects,
        for otu=1:numOTUs(ds),
            % sample new signature (signatureStar) from prior
            signatureStar = inactiveSignatures(1);
            temp_c_lambda = [];
            delta_lambda = [];
            [c_mu(signatureStar),X(signatureStar,:),lambda_1(signatureStar),temp_c_lambda,delta_lambda] = generateNewSignatureFromPrior(beta_0,R_inv,pi_c_mu,pi_c_lambda,beta_lambda_1,rho_lambda_1,rho_lambda_2,c_mu_MapDim,c_lambda_Configs);
            if ~isempty(temp_c_lambda),
                c_lambda(signatureStar) = temp_c_lambda;
                lambda_2(signatureStar,:) = delta_lambda;
            end;
            Bt = designMatrix(times{ds},timeIntervals{ds},lambda_1(signatureStar),delta_lambda,hparams.lambdaMin,hparams.lambdaMax);
            BXt = Bt*X(signatureStar,:)';

            currentSignature = signatureAssigns{ds}(otu);
            
            % calculate conditional likelihoods for all signatures for this
            % refOTU time-series
            temp_nu{ds}(activeSignatures,:) = BX{ds}(activeSignatures,:) + hparams.gamma{ds}(otu) + repmat(psi{ds},numSignatures,1);
            temp_nu{ds}(signatureStar,:) = BXt' + hparams.gamma{ds}(otu) + psi{ds};
            temp_enu{ds}(activeSignatures,:) = exp(temp_nu{ds}(activeSignatures,:));
            temp_enu{ds}(signatureStar,:) = exp(temp_nu{ds}(signatureStar,:));
            L([activeSignatures ; signatureStar]) = calcDataLL(repmat(D{ds}(otu,:),numSignatures+1,1),temp_enu{ds}([activeSignatures ; signatureStar],:),noTreatTimeIdx{ds},treatTimeIdx{ds},exp(epsilon_1),exp(epsilon_2));

            % check for any likelihoods that have gone outside precision
            % thresholds
            Lt = L([activeSignatures ; signatureStar])';
            f = find(isinf(Lt));
            Lt(f) = NaN;
            maxL = max(Lt);
            
            % remove this refOTU time-series from its current signature
            % assignment
            numSignatureMembers(currentSignature) = numSignatureMembers(currentSignature)-1;
            
            % find # of refOTUs assigned to each signature
            r1 = numSignatureMembers([activeSignatures ; signatureStar]);
            ff = find(r1==0);
            % if no refOTUs assigned, set to concentration parameter
            r1(ff) = alpha;
            % calculate conditional likelihood, scaling by maxL to avoid
            % numerical precision issues
            Lt = (r1/r2).*exp(Lt-maxL);
            f = find(isnan(Lt));
            Lt(f) = 0.0;
            
            if sum(Lt) > 0.0,
                % sample signature assignment based on conditional
                % likelihoods
                newSignature = sample(Lt);
                if newSignature <= length(activeSignatures),
                    newSignature = activeSignatures(newSignature);
                else,
                    newSignature = signatureStar;
                end;
                % if the assignment is to a new signature, we'll need
                % to update some variables
                if newSignature ~= currentSignature,
                    signatureAssigns{ds}(otu) = newSignature;
                    enu{ds}(otu,:) = temp_enu{ds}(newSignature,:);
                    nu{ds}(otu,:) = temp_nu{ds}(newSignature,:);
                    LL_data{ds}(otu) = L(newSignature);
                    % if the assignment is signatureStar, we'll need to
                    % update the set of active signatures and likelihoods
                    % for all refOTUs relative to signatureStar
                    if newSignature == signatureStar,
                        activeSignatures = [activeSignatures ; signatureStar];
                        inactiveSignatures(1) = [];
                        Btt = cell(numSubjects,1);
                        Btt{ds} = Bt;
                        BX{ds}(newSignature,:) = BXt;
                        for ds2=1:numSubjects,
                            if ds2 ~= ds,
                                delta_lambda = [];
                                if ~isempty(lambda_2),
                                    delta_lambda = lambda_2(signatureStar,:);
                                end;
                                Btt{ds2} = designMatrix(times{ds2},timeIntervals{ds2},lambda_1(signatureStar),delta_lambda,hparams.lambdaMin,hparams.lambdaMax);
                                BX{ds2}(newSignature,:) = Btt{ds2}*X(signatureStar,:)';
                            end;
                        end;
                        B{signatureStar} = Btt;
                        numSignatures = numSignatures + 1;
                    end;
                    
                    % if old signature has no members, delete it
                    % from the active list
                    if numSignatureMembers(currentSignature) == 0,
                        ft = find(activeSignatures == currentSignature);
                        activeSignatures(ft) = [];
                        inactiveSignatures = [currentSignature ; inactiveSignatures];
                        numSignatures = numSignatures - 1;
                    end;
                    
                    if numSignatures == signatureBuffer,
                        % resize arrays to accomodate more signatures, if
                        % necessary
                        signatureBuffer = signatureBuffer + 1;
                        c_mu((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                        X((signatureBuffer+1):(signatureBuffer+growSignatureBuffer),:) = zeros(1,size(X,2));
                        for gsb=(signatureBuffer+1):(signatureBuffer+growSignatureBuffer),
                            B{gsb} = cell(numSubjects,1);
                        end;
                        lambda_1((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                        if ~isempty(c_lambda),
                            c_lambda((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                            lambda_2((signatureBuffer+1):(signatureBuffer+growSignatureBuffer),:) = zeros(1,size(lambda_2,2));
                        end;
                        numSignatureMembers((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                        L((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                        reverseSignatureMap((signatureBuffer+1):(signatureBuffer+growSignatureBuffer)) = 0;
                        for ds2=1:numSubjects,
                            temp_enu{ds2}((signatureBuffer+1):(signatureBuffer+growSignatureBuffer),:) = zeros(1,numTimepoints(ds2));
                            temp_nu{ds2}((signatureBuffer+1):(signatureBuffer+growSignatureBuffer),:) = zeros(1,numTimepoints(ds2));
                            BX{ds2}((signatureBuffer+1):(signatureBuffer+growSignatureBuffer),:) = zeros(1,numTimepoints(ds2));
                        end;
                    end;
                    inactiveSignatures = [inactiveSignatures ; ((signatureBuffer+1):(signatureBuffer+growSignatureBuffer))'];
                    signatureBuffer = signatureBuffer + growSignatureBuffer;
                end;
            end;
            numSignatureMembers(signatureAssigns{ds}(otu)) = numSignatureMembers(signatureAssigns{ds}(otu))+1;
        end;
    end;
    
    % now that all refOTU time-series have been assigned, sample the
    % concentration parameter from the posterior
    alpha = sampleAlphaFromPosterior(numSignatures,sum(numOTUs),alpha,hparams.omega_alpha1,hparams.omega_alpha2,numAlphaIters);
    
    % for each signature, sample adapative complexity parameters, equilibrium level parameters, and relaxation time parameters from the posterior
    for ncc=1:numSignatures,
        % track attempted RJ moves
        total_try_X = total_try_X + 1;
        % find all refOTUs assigned to this signature
        k = activeSignatures(ncc);
        for ds=1:numSubjects,
            foundCM{ds} = find(signatureAssigns{ds} == k);
        end;
        
        % sample proposed new adaptive complexity parameters
        % chose bit to flip for c_mu
        flip_c_mu = unidrnd(log2(num_c_mu_states));
        do_flip = unidrnd(2);
        old_c_mu_state = c_mu_Configs(c_mu(k),:);
        new_c_mu_state = old_c_mu_state;
        if do_flip==2,
            if new_c_mu_state(flip_c_mu) == 1,
                new_c_mu_state(flip_c_mu) = 0;
            else,
                new_c_mu_state(flip_c_mu) = 1;
            end;
        end;
        new_c_mu = sum(new_c_mu_state.*convert_c_mu)+1;
        if ~isempty(c_lambda),
            % chose bit to flip for c_lambda
            flip_c_lambda = unidrnd(log2(num_c_lambda_states));
            do_flip = unidrnd(2);
            old_c_lambda_state = c_lambda_Configs(c_lambda(k),:);
            new_c_lambda_state = old_c_lambda_state;
            if do_flip==2,
                if new_c_lambda_state(flip_c_lambda) == 1,
                    new_c_lambda_state(flip_c_lambda) = 0;
                else,
                    new_c_lambda_state(flip_c_lambda) = 1;
                end;
            end;
            new_c_lambda = sum(new_c_lambda_state.*convert_c_lambda)+1;
        end;
        
        % sample new lambda_1 from proposal distribution centered
        % at previous lambda_1, with fixed variance
        lambda_new = normrnd(lambda_1(k),s_tune_lambda_1);
        % now sample delta_lambda increments
        delta_lambda_new = [];
        if ~isempty(c_lambda),
            delta_lambda_new = zeros(1,length(lambda_2(k,:)));
            for dl=1:length(new_c_lambda_state),
                if new_c_lambda_state(dl) == 1,
                    delta_lambda_new(dl) = normrnd(lambda_2(k,dl),s_tune_lambda_2);
                end;
            end;
        end;
        
        % generate temporary design matrices based on new proposals
        B_new_save = cell(numSubjects,1);
        B_new = cell(numSubjects,1);
        np = 0;
        for ds=1:numSubjects,
            if ~isempty(foundCM{ds}),
                B_new_save{ds} = designMatrix(times{ds},timeIntervals{ds},lambda_new,delta_lambda_new,hparams.lambdaMin,hparams.lambdaMax);
                B_new{ds} = B_new_save{ds};
                B_new{ds}(:,c_mu_DelDim{new_c_mu}) = [];
                np = size(B_new{ds},2);
            end;
        end;
        
        % transform observed data (needed for WLS estimate), relative to
        % prior state of the chain
        [B_D,B_W] = transformData(foundCM,np,B_new,D,psiM,gammaM,nu,enu,exp(epsilon_1),exp(epsilon_2),noTreatTimeIdx,treatTimeIdx);
        % calculate WLS covariance matrix (dimension will depend on c_mu)
        C = (R_inv{new_c_mu}+B_W);
        C = inv(C);
        % check that cov matrix is pos semidefinite
        [TTM,err] = cholcov(C,0);
        if err == 0,
            po_new =  [R_inv{new_c_mu}(1,1)*beta_0 ; zeros(size(B_new{1},2)-1,1)];
            % calculate WLS mean estimate relative to new proposal
            m = C * (B_D+po_new);
            % sample new proposal for equilibrium levels
            % from WLS estimate distribution
            X_new = mvnrnd(m,C)';
            % calculate GLM parameters for all refOTUs that belong to this
            % signature
            for ds=1:numSubjects,
                if ~isempty(foundCM{ds}),
                    nu_new{ds}(foundCM{ds},:) = repmat((B_new{ds}*X_new)',length(foundCM{ds}),1) + psiM{ds}(foundCM{ds},:) + gammaM{ds}(foundCM{ds},:);
                    enu_new{ds}(foundCM{ds},:) = exp(nu_new{ds}(foundCM{ds},:));
                end;
            end;
            
            % calculate components for the acceptance probability
            % numerator, which are relative to the proposed new state
            p1_X_data = 0.0;
            p2_X_data = 0.0;
            for ds=1:numSubjects,
                if ~isempty(foundCM{ds}),
                    temp_LL{ds}(foundCM{ds}) = calcDataLL(D{ds}(foundCM{ds},:),enu_new{ds}(foundCM{ds},:),noTreatTimeIdx{ds},treatTimeIdx{ds},exp(epsilon_1),exp(epsilon_2));
                    % data log likelihood given the new proposal
                    p1_X_data = p1_X_data + sum(temp_LL{ds}(foundCM{ds}));
                    % data log likelihood given the old proposal
                    p2_X_data = p2_X_data + sum(LL_data{ds}(foundCM{ds}));
                end;
            end;
            % log likelihood of prior on equilibrium levels
            % parameters given new proposal
            p1_X_prior = sum(log(normpdf(X_new,po_new,sqrt(1./diag(R_inv{new_c_mu})))));
            % for numerator of acceptance probability, add log likelihood
            % of data, and priors on equilibrium levels,
            % lambda_1, c_mu, and c_lambda given new proposal
            p1 = p1_X_data + p1_X_prior + log(pi_c_mu(new_c_mu)) + log(normpdf(lambda_new,beta_lambda_1,rho_lambda_1));
            if ~isempty(c_lambda),
                p1 = p1 + log(pi_c_lambda(new_c_lambda));
                % add on priors for delta_lambda
                for dl=1:length(new_c_lambda_state),
                    if new_c_lambda_state(dl) == 1,
                        p1 = p1 + log(normpdf(delta_lambda_new(dl),0,rho_lambda_2));
                    end;
                end;
            end;
            
            % now calculate components of the acceptance probability
            % denominator, which are analogous to above, but relative to the prior (old) state of
            % the chain
            X_old = X(k,:);
            X_old(c_mu_DelDim{c_mu(k)}) = [];
            B_old = cell(numSubjects,1);
            np = 0;
            for ds=1:numSubjects,
                if ~isempty(foundCM{ds}),
                    delta_lambda = [];
                    if ~isempty(lambda_2),
                        delta_lambda = lambda_2(k,:);
                    end;
                    B_old{ds} = designMatrix(times{ds},timeIntervals{ds},lambda_1(k),delta_lambda,hparams.lambdaMin,hparams.lambdaMax);
                    B_old{ds}(:,c_mu_DelDim{c_mu(k)}) = [];
                    np = size(B_old{ds},2);
                end;
            end;
            po_old =  [R_inv{c_mu(k)}(1,1)*beta_0 ; zeros(size(B_old{1},2)-1,1)];
            p2_X_prior = sum(log(normpdf(X_old',po_old,sqrt(1./diag(R_inv{c_mu(k)})))));
            p2 = p2_X_data + p2_X_prior + log(pi_c_mu(c_mu(k))) + log(normpdf(lambda_1(k),beta_lambda_1,rho_lambda_1));
            if ~isempty(c_lambda),
                p2 = p2 + log(pi_c_lambda(c_lambda(k)));
                for dl=1:length(old_c_lambda_state),
                    if old_c_lambda_state(dl) == 1,
                        p2 = p2 + log(normpdf(lambda_2(k,dl),0,rho_lambda_2));
                    end;
                end;
            end;
            
            % calculate WLS estimate relative to new state of the chain
            [B_D,B_W] = transformData(foundCM,np,B_old,D,psiM,gammaM,nu_new,enu_new,exp(epsilon_1),exp(epsilon_2),noTreatTimeIdx,treatTimeIdx);
            C_new = (R_inv{c_mu(k)}+B_W);
            C_new = inv(C_new);
            
            % check that WLS cov estimate is pos semidefinite
            [TTM,err] = cholcov(C_new,0);
            if err == 0,
                m_new = C_new * (B_D+po_old);
                
                % calculate component of jumping probabilities for
                % equilibrium level parameters
                q1 = log(mvnpdf(X_new,m,C));
                q2 = log(mvnpdf(X_old',m_new,C_new));
                if ~isempty(c_lambda),
                    % add component to jumping probabilities for lambda
                    % parameters
                    if new_c_lambda_state(flip_c_lambda) == 0 && old_c_lambda_state(flip_c_lambda) == 1,
                        q2 = q2 + log(normpdf(lambda_2(k,flip_c_lambda),0,s_tune_lambda_2));
                    end;
                    if new_c_lambda_state(flip_c_lambda) == 1 && old_c_lambda_state(flip_c_lambda) == 0,
                        q1 = q1 + log(normpdf(delta_lambda_new(flip_c_lambda),0,s_tune_lambda_2));
                    end;
                end;
                
                % calculate acceptance probability
                r = p1 - q1 - p2 + q2;
                r = min(1.0,exp(r));
                if isinf(p1),
                    r = 0;
                end;
                
                u = unifrnd(0,1);

                if u <= r,
                    % accept the proposal
                    num_accept_X = num_accept_X + 1;
                    % update design matrices given new parameters
                    for ds=1:numSubjects,
                        if isempty(foundCM{ds}),
                            B_new_save{ds} = designMatrix(times{ds},timeIntervals{ds},lambda_new,delta_lambda_new,hparams.lambdaMin,hparams.lambdaMax);
                            B_new{ds} = B_new_save{ds};
                            B_new{ds}(:,c_mu_DelDim{new_c_mu}) = [];
                        end;
                        BX{ds}(k,:) = (B_new{ds}*X_new)';
                    end;
                    % update GLM parameters
                    for ds=1:numSubjects,
                        if ~isempty(foundCM{ds}),
                            nu{ds}(foundCM{ds},:) = nu_new{ds}(foundCM{ds},:);
                            enu{ds}(foundCM{ds},:) = enu_new{ds}(foundCM{ds},:);
                            LL_data{ds}(foundCM{ds}) = temp_LL{ds}(foundCM{ds});
                        end;
                    end;
                    
                    % update signature parameters
                    X(k,:) = 0*X(k,:);
                    X(k,c_mu_MapDim{new_c_mu}) = X_new;
                    c_mu(k) = new_c_mu;
                    lambda_1(k) = lambda_new;
                    if ~isempty(lambda_2),
                        lambda_2(k,:) = delta_lambda_new;
                        c_lambda(k) = new_c_lambda;
                    end;
                end;
            end;
        end;
    end;
    
    % sample new epsilon_1 from proposal distribution
    epsilon_1_new = normrnd(epsilon_1,v_epsilon_1_sample);
    p1_epsilon1_data = 0.0;
    p2_epsilon1_data = 0.0;
    % recalculate data loglikelihood given proposed epsilon_1
    for ds=1:numSubjects,
        temp_LL{ds} = calcDataLL(D{ds},enu{ds},noTreatTimeIdx{ds},treatTimeIdx{ds},exp(epsilon_1_new),exp(epsilon_2));
        p1_epsilon1_data = p1_epsilon1_data + sum(temp_LL{ds});
        p2_epsilon1_data = p2_epsilon1_data + sum(LL_data{ds});
    end;
    % calculate log likelihood for prior on epilson_1
    p1_epsilon1_prior = log(normpdf(epsilon_1_new,mu_epsilon_1,rho_epsilon_1));
    % numerator for acceptance probability
    p1 = p1_epsilon1_data + p1_epsilon1_prior;
    % denominator for acceptance probability
    p2 = p2_epsilon1_data + log(normpdf(epsilon_1,mu_epsilon_1,rho_epsilon_1));
    % calculate acceptance probability
    r = p1 - p2;
    r = min(1.0,exp(r));
    u = unifrnd(0,1);
    if isinf(p1),
        r = 0;
    end;
    if u <= r,
        % accept the proposal
        num_accept_epsilon1 = num_accept_epsilon1 + 1;
        epsilon_1 = epsilon_1_new;
        % update data loglikelihood given new epsilon_1
        for ds=1:numSubjects,
            LL_data{ds} = temp_LL{ds};
        end;
    end;

    % sample new epsilon_2 - steps are exactly analogous to sampling
    % epsilon_1
    epsilon_2_new = normrnd(epsilon_2,v_epsilon_2_sample);
    p1_epsilon2_data = 0.0;
    p2_epsilon2_data = 0.0;
    for ds=1:numSubjects,
        temp_LL{ds} = calcDataLL(D{ds},enu{ds},noTreatTimeIdx{ds},treatTimeIdx{ds},exp(epsilon_1),exp(epsilon_2_new));
        p1_epsilon2_data = p1_epsilon2_data + sum(temp_LL{ds});
        p2_epsilon2_data = p2_epsilon2_data + sum(LL_data{ds});
    end;
    p1_epsilon2_prior = log(normpdf(epsilon_2_new,mu_epsilon_2,rho_epsilon_2));
    p1 = p1_epsilon2_data + p1_epsilon2_prior;
    p2 = p2_epsilon2_data + log(normpdf(epsilon_2,mu_epsilon_2,rho_epsilon_2));
    r = p1 - p2;
    r = min(1.0,exp(r));
    u = unifrnd(0,1);
    if isinf(p1),
        r = 0;
    end;
    if u <= r,
        % accept the proposal
        num_accept_epsilon2 = num_accept_epsilon2 + 1;
        epsilon_2 = epsilon_2_new;
        for ds=1:numSubjects,
            LL_data{ds} = temp_LL{ds};
        end;
    end;
    
    % now sample hyperparameters from the posterior
    beta_0 = sampleMeanPosterior(X(activeSignatures,1)',rho_0,hparams.m_beta_0,hparams.sigma_beta_0);
    rho_0 = sampleSTDPosterior(X(activeSignatures,1)',beta_0,sqrt(hparams.v_rho_0),hparams.nu_rho_0);
    
    % for sampling rho_mu_1, need to take into account cases in which c_mu has
    % 'removed' equilibrium parameters
    Xt = [];
    for kk=1:length(activeSignatures),
        k = activeSignatures(kk);
        f = find(c_mu_Configs(c_mu(k),:) == 1);
        if ~isempty(f),
            Xt = [Xt X(k,c_mu_idx(f))];
        end;
    end;
    rho_mu_1 = sampleSTDPosterior(Xt,0,sqrt(hparams.v_rho_mu_1),hparams.nu_rho_mu_1);
   
    % for sampling rho_mu_2, include parameters on treatment intervals
    ti = [];
    for intv=1:length(timeIntervals{1}),
        if timeIntervals{1}{intv}.treat == 1,
            ti = [ti intv];
        end;
    end;
    Xt = reshape(X(activeSignatures,ti),1,length(ti)*length(activeSignatures));
    rho_mu_2 = sampleSTDPosterior(Xt,0,sqrt(hparams.v_rho_mu_2),hparams.nu_rho_mu_2);
    
    % sample parameters for prior on lambda_1
    beta_lambda_1 = sampleMeanPosterior(lambda_1(activeSignatures),rho_lambda_1,hparams.m_beta_lambda_1,hparams.sigma_beta_lambda_1);
    rho_lambda_1 = sampleSTDPosterior(lambda_1(activeSignatures),beta_lambda_1,sqrt(hparams.v_rho_lambda_1),hparams.nu_rho_lambda_1);
    
    % sample parameters for prior on lambda_2
    % in this case, need to take into account cases in which c_lambda has
    % removed relaxation time parameter(s)
    if ~isempty(c_lambda),
        Xt = [];
        for kk=1:length(activeSignatures),
            k = activeSignatures(kk);
            f = find(c_lambda_Configs(c_lambda(k),:) == 1);
            if ~isempty(f),
                Xt = [Xt lambda_2(k,f)];
            end;
        end;
        rho_lambda_2 = sampleSTDPosterior(Xt,0,sqrt(hparams.v_rho_lambda_2),hparams.nu_rho_lambda_2);
    end;
    
    % sample prior for c_mu
    c_mu_counts = zeros(1,num_c_mu_states);
    for cmc=1:length(c_mu_counts),
        f = find(c_mu(activeSignatures) == cmc);
        c_mu_counts(cmc) = length(f);
    end;
    pi_c_mu = dirichlet_sample(c_mu_counts+hparams.omega_pi_c_mu);
    
    % sample prior for c_lambda
    if ~isempty(c_lambda),
        c_lambda_counts = zeros(1,num_c_lambda_states);
        for cmc=1:length(c_lambda_counts),
            f = find(c_lambda(activeSignatures) == cmc);
            c_lambda_counts(cmc) = length(f);
        end;
        pi_c_lambda = dirichlet_sample(c_lambda_counts+hparams.omega_pi_c_lambda);
    end;
    
    % create new R_inv matrices used for efficient sampling
    for j=1:num_c_mu_states,
        vp = zeros(1,length(timeIntervals{1}));
        vp(1) = rho_0^2;
        for intv=2:length(timeIntervals{1}),
            if timeIntervals{1}{intv}.treat == 0,
                vp(intv) = rho_mu_1^2;
            else,
                vp(intv) = rho_mu_2^2;
            end;
        end;
        if ~isempty(c_mu_DelDim{j}),
            vp(c_mu_DelDim{j}) = [];
        end;
        R_inv{j} = diag(1./vp);
    end;
    
    % output diagnostics with
    % iter = MCMC iteration
    % nc = number of active signatures
    % alpha = concentration parameter
    % SD1_mu = SD1_mu for this iteration
    % SD1_lm = SD1_lm for this iteration
    % ep1 = epsilon_1
    % ep2 = epsilon_2
    % acX = acceptance rate for RJ moves
    % acEp1 = acceptance rate for MH move for epsilon_1
    % acEp2 = acceptance rate for MH move for epsilon_2
    if mod(iter,100)==0,
        if ~isempty(c_lambda),
            sds = sprintf('iter=%i nc=%i alpha=%f SD1_mu=%f SD1_lm=%f ep1=%f ep2=%f acX=%f acEp1=%f acEp2=%f',iter,numSignatures,alpha,1.0-c_mu_counts(1)/length(activeSignatures),1.0-c_lambda_counts(1)/length(activeSignatures),exp(epsilon_1),exp(epsilon_2),num_accept_X/total_try_X, num_accept_epsilon1/iter,num_accept_epsilon2/iter);
        else,
            sds = sprintf('iter=%i nc=%i alpha=%f SD1_mu=%f ep1=%f ep2=%f acX=%f acEp1=%f acEp2=%f',iter,numSignatures,alpha,1.0-c_mu_counts(1)/length(activeSignatures),exp(epsilon_1),exp(epsilon_2),num_accept_X/total_try_X, num_accept_epsilon1/iter,num_accept_epsilon2/iter);
        end;
        if nodeID > -1,
            sds = [sprintf('nid=%i ',nodeID) sds];
        end;
        disp(sds);
    end;
    % after burnin, output samples to files
    if iter >= num_MCMC_burnin,
        reverseSignatureMap(activeSignatures) = 1:numSignatures;
        outputSample(fid_hyperParams,fid_signatureParameters,fid_signatureAssigns,numSignatures,activeSignatures,reverseSignatureMap,alpha,signatureAssigns,X,lambda_1,lambda_2,c_mu,c_lambda,epsilon_1,epsilon_2,beta_0,beta_0,rho_mu_1,rho_mu_2,beta_lambda_1,rho_lambda_1,rho_lambda_2);
    end;
end;

function [c_mu,X,lambda_1,c_lambda,delta_lambda] = generateNewSignatureFromPrior(beta_0,R_inv,pi_c_mu,pi_c_lambda,beta_lambda_1,rho_lambda_1,rho_lambda_2,c_mu_MapDim,c_lambda_Configs)
    % sample a new signature from the prior
    c_mu = sample(pi_c_mu);
    s = sqrt(diag(1./R_inv{c_mu}));
    Xt = normrnd([beta_0 zeros(1,length(s)-1)],s');
    lambda_1 = normrnd(beta_lambda_1,rho_lambda_1);
    c_lambda = [];
    delta_lambda = [];
    if ~isempty(pi_c_lambda),
        c_lambda = sample(pi_c_lambda);
        c_lambda_config = c_lambda_Configs(c_lambda,:);
        delta_lambda = zeros(1,length(c_lambda_config));
        for dl=1:length(delta_lambda),
            if c_lambda_config(dl) > 0,
                delta_lambda(dl) = normrnd(0,rho_lambda_2);
            end;
        end;
    end;
    X = zeros(1,size(R_inv{length(R_inv)},1));
    X(c_mu_MapDim{c_mu}) = Xt;

function [LL] = calcDataLL(D,enu,timesI_nonabx,timesI_abx,epsilon_1,epsilon_2)
    % calculate loglikelihood of the data; calculate
    % antibiotic exposure and non-antibiotic exposure intervals separately,
    % as they use different epsilon parameters
    LL = calcDataLLTimes(D,enu,timesI_nonabx,epsilon_1) + calcDataLLTimes(D,enu,timesI_abx,epsilon_2);
    
function [LL] = calcDataLLTimes(D,enu,times,epsilon)
    % calculate data likelihood under the Negative Binomial Distribution
    % parameterized by mean enu and parameter epsilon (controls variance)
    ek = 1/epsilon;   
    LL = gammaln(D(:,times)+ek)  -gammaln(ek) + D(:,times).*log(enu(:,times)) + ek*log(ek) - (D(:,times) + ek).*log(enu(:,times)+ek);
    LL = sum(LL,2);
    
function [alpha_new] = sampleAlphaFromPosterior(numSignatures,numDataPoints,alpha_old,omega_alpha1,omega_alpha2,numAlphaIters)
% sample concentration parameter using method of Escobar & West (see SI
% Methods)
    eta = 0.0;
    zz = 0;
    w = zeros(2,1);
    alpha_new = alpha_old;

    if numSignatures <= 1,
        return;
    end;
    
    gi = 0;
    at = 0.0;

    for i=1:numAlphaIters,
        eta = betarnd(alpha_new+1.0,numDataPoints);
        if eta > 0.0,
            w(1) = (omega_alpha1 + numSignatures - 1)/(omega_alpha2 - log(eta));
            w(2) = numDataPoints;
            zz = sample(w,1);
            w(1) = omega_alpha2 - log(eta);
            if w(1) >= 0,
                if zz == 1,
                    alpha_new = gamrnd(omega_alpha1+numSignatures,1/w(1));
                else,
                    alpha_new = gamrnd(omega_alpha1+numSignatures-1,1/w(1));
                end;
                gi = gi + 1;
                at = at + alpha_new;
            end;
        end;
    end;
    if gi > 0,
        alpha_new = at/gi;
    else,
        alpha_new = alpha_old;
    end;
    
function [s] = sampleSTDPosterior(X,mu,s_p,dof)
    % sample standard deviation assuming normal likelihood and scaled
    % inverse chi^2 prior
    % X are the values of the 'data' RV
    % mu is the mean of the 'data' RV
    % s_p is the prior mean STD
    % dof is the degrees of freedom for the scaled inverse chi^2

    n = length(X);
    if n > 0,
        ss = sum((X-mu).^2);
    else,
        ss = 0;
    end;

    ss = (ss + dof*s_p^2)/2.0;
    s = gamrnd((dof+n)/2.0+2.0,1/ss);
    s = sqrt(1/s);

function [m] = sampleMeanPosterior(X,s,mu_p,s_p)
    % sample mean assuming normal likelihood and normal prior
    % X are the values of the 'data' RV
    % s is the STD for the 'data' RV
    % mu_p is the prior mean
    % s_p is the prior STD

    n = length(X);
    if n > 0,
        mus = sum(X);
    else,
        mus = 0;
    end;
    % posterior variance
    v_pos = 1/(1/s_p^2 + n/s^2);
    % posterior mean
    m_pos = (mu_p/s_p^2 + mus/s^2)*v_pos;
    m = normrnd(m_pos,sqrt(v_pos));
    
function [fid_hyperParams,fid_signatureParameters,fid_signatureAssigns] = initOutputFiles(baseDir,numSubjects)
    % initialize output files
    
    % file to contain hyperparameter samples
    hyperParamFileN = [baseDir '_hyperParams.txt'];
    % file to contain signature parameter samples (equilibrium level
    % and relaxation time parameters)
    signatureParametersFileN = [baseDir '_signatureParameters.txt'];
    % file to contain assignments of refOTU time-series to signatures
    signatureAssignsFileN = cell(numSubjects,1);
    for ds=1:numSubjects,
        signatureAssignsFileN{ds} = [baseDir '_signatureAssigns' int2str(ds) '.txt'];
    end;
   
    fid_hyperParams = fopen(hyperParamFileN,'w');
    fid_signatureParameters = fopen(signatureParametersFileN,'w');
    fid_signatureAssigns = cell(numSubjects,1);
    for ds=1:numSubjects,
        fid_signatureAssigns{ds} = fopen(signatureAssignsFileN{ds},'w');
    end;
    
function [] = outputSample(fid_hyperParams,fid_signatureParameters,fid_signatureAssigns,numSignatures,activeSignatures,reverseSignatureMap,alpha,signatureAssigns,X,lambda_1,lambda_2,c_mu,c_lambda,epsilon_1,epsilon_2,beta_0,rho_0,rho_mu_1,rho_mu_2, beta_lambda_1,rho_lambda_1,rho_lambda_2)
    % output MCMC samples

    % output hyperparameters
    if ~isempty(c_lambda),
        fprintf(fid_hyperParams,'%i\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n',numSignatures,alpha,epsilon_1,epsilon_2,beta_0,rho_0,rho_mu_1,rho_mu_2,beta_lambda_1,rho_lambda_1,rho_lambda_2);
    else,
        fprintf(fid_hyperParams,'%i\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n',numSignatures,alpha,epsilon_1,epsilon_2,beta_0,rho_0,rho_mu_1,rho_mu_2,beta_lambda_1,rho_lambda_1);
    end;

    % output signature parameters
    if ~isempty(c_lambda),
        X2 = [X(activeSignatures,:) lambda_1(activeSignatures) lambda_2(activeSignatures,:) c_mu(activeSignatures) c_lambda(activeSignatures)];
    else,
        X2 = [X(activeSignatures,:) lambda_1(activeSignatures) c_mu(activeSignatures)];
    end;
    X2 = reshape(X2',1,size(X2,2)*size(X2,1));
    fprintf(fid_signatureParameters,'%f',X2(1));
    fprintf(fid_signatureParameters,'\t%f',X2(2:length(X2)));
    fprintf(fid_signatureParameters,'\n');
    
    % output signatureAssignments
    for ds=1:length(signatureAssigns),
        fprintf(fid_signatureAssigns{ds},'%i',reverseSignatureMap(signatureAssigns{ds}(1)));
        fprintf(fid_signatureAssigns{ds},'\t%i',reverseSignatureMap(signatureAssigns{ds}(2:length(signatureAssigns{ds}))));
        fprintf(fid_signatureAssigns{ds},'\n');
    end;
    
function r = dirichlet_sample(a,n)
% function from Tom Minka's FastFit toolbox http://research.microsoft.com/en-us/um/people/minka/software/fastfit/
% DIRICHLET_SAMPLE   Sample from Dirichlet distribution.
%
% DIRICHLET_SAMPLE(a) returns a probability vector sampled from a 
% Dirichlet distribution with parameter vector A.
% DIRICHLET_SAMPLE(a,n) returns N samples, collected into a matrix, each 
% vector having the same orientation as A.
%
%   References:
%      [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
%      Springer-Verlag, 1986

% This is essentially a generalization of the method for Beta rv's.
% Theorem 4.1, p.594

if nargin < 2
  n = 1;
end

row = (rows(a) == 1);

a = a(:);
% randgamma is faster
y = randgamma(repmat(a, 1, n));
r = col_sum(y);
r(find(r == 0)) = 1;
r = y./repmat(r, rows(y), 1);
if row
  r = r';
end

function [stateBits] = enumStates(numStates)
% enumerate states as vectors of bits

stateBits = zeros(numStates,log2(numStates));
for s=1:numStates,
    sb = dec2base(s-1,2);
    while length(sb) < log2(numStates),
        sb = ['0' sb];
    end;
    for i=length(sb):-1:1,
        switch sb(i),
            case '0'
                stateBits(s,length(sb)-i+1) = 0;
            case '1'
                stateBits(s,length(sb)-i+1) = 1;
        end;
    end;
end;