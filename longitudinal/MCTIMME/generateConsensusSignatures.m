function [consensusSignatures] = generateConsensusSignatures(CSGs,refSubject,hparams,times,timeIntervals,baseDir)
% using MCMC samples as input, for each refOTU in each subject, output a median signature w/ 95%
% credible interval, and estimates of c_mu and c_lambda state probabilities
%
% inputs:
% CSGs = cell array, such that Cl{i} is an array specifying members of
% consensus signature group i as refOTUObjects, generated by
% consensusSignatureGroups function
% hparams = hyperparameters object
% psi = subject & time-point specific offsets, calculated by filterData
% times = cell array of time-points for each subject
% timeIntervals = array specifying time-intervals for each subject
% baseDir = directory containing MCMC sample output
%
% output:
% consensusSignatures = cell array of signatureObjects
%
% Microbial Counts Trajectories Infinite Mixture Model Engine (MC-TIMME)
% Copyright (C) 2012 Georg Gerber
% generateConsensusSignatures.m (version 1.00)

% separate time intervals into non-treatment and treatment (antibiotic)
% intervals
[treatIntervals,noTreatIntervals,treatTimeIdx,noTreatTimeIdx] = separateIntervals(timeIntervals);
numMuParams = length(noTreatIntervals{1});
numGLMParams = length(timeIntervals{1});
numDeltaLambdaParams = numMuParams-2;
num_c_mu_states = 2^(numMuParams-1);
num_c_lambda_states = 2^numDeltaLambdaParams;

% # of signature parameters includes equilibrium level,
% relaxation time, and adaptive complexity parameters
numSignatureParameters = length(timeIntervals{1})+2;
if numDeltaLambdaParams>0,
    numSignatureParameters = numSignatureParameters + numDeltaLambdaParams + 1;
end;

numSubjects = length(hparams.gamma);

% create standard time-line
maxTime = max(times{refSubject});
itimes = (1:maxTime)';
itimeIntervals = cell(length(timeIntervals{refSubject}),1);
for intv=1:length(timeIntervals{refSubject}),
    ti = timeIntervals{refSubject}{intv};
    ti2 = timeIntervalObject;
    ti2.treat = ti.treat;
    ti2.startTimeIdx = times{refSubject}(ti.startTimeIdx);
    ti2.endTimeIdx = times{refSubject}(ti.endTimeIdx);
    itimeIntervals{intv} = ti2;
end;

% load assignments of refOTU time-series to signatures for each MCMC sample
signatureAssignsFileN = cell(numSubjects,1);
signatureAssigns = cell(numSubjects,1);
numOTUs = zeros(numSubjects,1);
for ds=1:numSubjects,
    signatureAssignsFileN{ds} = [baseDir '_signatureAssigns' int2str(ds) '.txt'];
    signatureAssigns{ds} = dlmread(signatureAssignsFileN{ds});
    numOTUs(ds) = length(hparams.gamma{ds});
end;

% get # of signatures in each MCMC sample
hyperParamFileN = [baseDir '_hyperParams.txt'];
H = dlmread(hyperParamFileN);
numSignatures = H(:,1);

% get signature parameters from each MCMC sample
signatureParametersFileN = [baseDir '_signatureParameters.txt'];
numSamples = size(H,1);
samples = cell(numSamples,1);
fid = fopen(signatureParametersFileN,'r');
for i=1:numSamples,
    tline = fgetl(fid);
    C = sscanf(tline,'%f');
    nc = numSignatures(i)*numSignatureParameters;
    C = C(1:nc);
    samples{i} = reshape(C,numSignatureParameters,numSignatures(i))';
end;
fclose(fid);

% initialize array for consensus signatures
consensusSignatures = cell(length(CSGs),1);

for ncc=1:length(CSGs),
    numMembers = length(CSGs{ncc});
    % temp variable to store trajectories (log NBD mean) from each sample
    M = zeros(numSamples*numMembers,length(itimes));
    % temp variable to store relaxation time parameters from each
    % sample
    L = zeros(numSamples*numMembers,numDeltaLambdaParams+1);
    % temp variable to store c_mu settings from each sample
    CP = zeros(1,num_c_mu_states);
    % temp variable to store c_lambda settings from each sample
    ULDP = [];
    if numDeltaLambdaParams > 0,
        ULDP = zeros(1,num_c_lambda_states);
    end;
    % counter of # of OTUs processed in this CSG
    nri = 0;
    for ds=1:numSubjects,
        % find refOTUs from this subject that belong to this CSG
        for onn=1:numMembers,
            roo = CSGs{ncc}{onn};
            if roo.subjNum == ds,
                otu = roo.OTUNum;
                for si=1:numSamples,
                    % index for storing samples relating to this CSG
                    s = nri*numSamples + si;
                    % get parameters from MCMC sample
                    k = signatureAssigns{ds}(si,otu);
                    C = samples{si};
                    Xt = C(k,1:numGLMParams);
                    lambda_1 = C(k,numGLMParams+1);
                    delta_lambda = [];
                    if ~isempty(ULDP),
                        delta_lambda = C(k,(numGLMParams+2):(numGLMParams+2+numDeltaLambdaParams-1));
                    end;
                    c_lambda = [];
                    if numDeltaLambdaParams>0,
                        c_mu = C(k,numSignatureParameters-1);
                        c_lambda = C(k,numSignatureParameters);
                    else,
                        c_mu = C(k,numSignatureParameters);
                    end;
                    
                    B = designMatrix(itimes,itimeIntervals,lambda_1,delta_lambda,hparams.lambdaMin,hparams.lambdaMax);
                    M(s,:) = (B*Xt')';
                    lambda1 = (exp(lambda_1)/(1+exp(lambda_1)))*(hparams.lambdaMax-hparams.lambdaMin) + hparams.lambdaMin;
                    lambda2 = [];
                    if ~isempty(ULDP),
                        currentLambda = lambda_1;
                        lambda_2 = zeros(1,length(delta_lambda));
                        for dl=1:length(delta_lambda),
                            currentLambda = currentLambda+delta_lambda(dl);
                            lambda_2(dl) = (exp(currentLambda)/(1+exp(currentLambda)))*(hparams.lambdaMax-hparams.lambdaMin) + hparams.lambdaMin;
                        end;
                    end;
                    % concatenate lambda parameters
                    L(s,1) = lambda1;
                    if ~isempty(ULDP),
                        L(s,2:(numDeltaLambdaParams+1)) = lambda_2;
                    end;
                    c_lambda = [];
                    if numDeltaLambdaParams>0,
                        c_mu = C(k,numSignatureParameters-1);
                        c_lambda = C(k,numSignatureParameters);
                    else,
                        c_mu = C(k,numSignatureParameters);
                    end;
                    % count # of times each c_mu or c_lambda state occurs
                    CP(c_mu) = CP(c_mu)+1;
                    if ~isempty(ULDP),
                        ULDP(c_lambda) = ULDP(c_lambda)+1;
                    end;
                end;
                nri = nri + 1;
            end;
        end;
    end;
    M = prctile(M,[2.5 50 97.5]);
    L = prctile(L,[2.5 50 97.5]);
    CP = CP/(numSamples*numMembers);
    if ~isempty(ULDP),
        ULDP = ULDP/(numSamples*numMembers);
    end;

    % instantiate signature object
    ts = signatureObject;
    ts.q025_trajectory = M(1,:);
    ts.med_trajectory = M(2,:);
    ts.q975_trajectory = M(3,:);
    
    if ~isempty(ULDP),
        ts.q025_relaxation_params = L(1,:);
        ts.med_relaxation_params = L(2,:);
        ts.q975_relaxation_params = L(3,:);
    else,
        ts.q025_relaxation_params = L(1);
        ts.med_relaxation_params = L(2);
        ts.q975_relaxation_params = L(3);
    end;
    ts.c_mu_probs = CP;
    ts.c_lambda_probs = ULDP;

    consensusSignatures{ncc} = ts;
    os = sprintf('CSG %i',ncc);
    disp(os);
end;